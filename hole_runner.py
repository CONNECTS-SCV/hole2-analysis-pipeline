#!/usr/bin/env python3
"""
HOLE Program Python Wrapper
============================
이온 채널의 기공 크기 분석을 위한 HOLE 프로그램 실행 래퍼

사용 예시:
---------
from hole_runner import run_hole, parse_hole_output

# HOLE 실행
result = run_hole("protein.pdb", output_prefix="my_analysis")

# 결과 파싱
if result['success']:
    data = parse_hole_output(result['output_file'])
    for point in data:
        print(f"Position: {point['position']:.2f}, Radius: {point['radius']:.2f}")
"""

import subprocess
import os
from pathlib import Path
import re

# HOLE 프로그램 경로 설정
HOLE_EXE = os.path.expanduser("~/MODEL/hole2/exe/hole")
HOLE_RAD = os.path.expanduser("~/MODEL/hole2/rad/simple.rad")


def run_hole(pdb_file, output_prefix="hole", endrad=5.0, work_dir=".",
             radius_file=None, additional_cards=None, ignore_residues=None):
    """
    HOLE 프로그램을 실행하는 함수

    Parameters
    ----------
    pdb_file : str
        PDB 파일 경로 (절대 경로 또는 상대 경로)
    output_prefix : str, optional
        출력 파일 접두사 (기본값: "hole")
    endrad : float, optional
        채널 종료 반지름 (Angstrom, 기본값: 5.0)
        좁은 채널의 경우 5.0, 넓은 채널의 경우 더 큰 값 사용
    work_dir : str, optional
        작업 디렉토리 (기본값: 현재 디렉토리)
    radius_file : str, optional
        반지름 파일 경로 (기본값: simple.rad)
        다른 옵션: amberuni.rad, bondi.rad, hardcore.rad, xplor.rad
    additional_cards : dict, optional
        추가 HOLE 입력 카드 (예: {'cvect': '0 0 1'})

    Returns
    -------
    dict
        실행 결과 정보:
        - 'success': bool - 성공 여부
        - 'output_file': str - 출력 텍스트 파일 경로
        - 'sph_file': str - 구 중심 PDB 파일 경로
        - 'input_file': str - 입력 파일 경로
        - 'stderr': str - 표준 에러 출력
        - 'min_radius': float - 최소 기공 반지름 (성공 시)

    Examples
    --------
    >>> result = run_hole("1grm.pdb", endrad=5.0)
    >>> if result['success']:
    ...     print(f"Minimum radius: {result['min_radius']:.2f} Å")
    """

    # 작업 디렉토리 생성
    work_path = Path(work_dir).resolve()
    work_path.mkdir(parents=True, exist_ok=True)

    # PDB 파일 절대 경로로 변환
    pdb_path = Path(pdb_file).resolve()
    if not pdb_path.exists():
        return {
            'success': False,
            'error': f'PDB file not found: {pdb_path}'
        }

    # 반지름 파일 설정
    if radius_file is None:
        radius_file = HOLE_RAD
    else:
        radius_file = os.path.expanduser(radius_file)

    # 출력 파일 경로
    input_file = work_path / f"{output_prefix}.inp"
    output_file = work_path / f"{output_prefix}_out.txt"
    sph_file = work_path / f"{output_prefix}.sph"
    pdb_copy = work_path / f"{output_prefix}.pdb"

    # HOLE 입력 카드 작성
    input_content = f"""! HOLE input file generated by Python
! Analysis of: {pdb_path.name}
coord {pdb_path}
radius {radius_file}
sphpdb {sph_file.name}
endrad {endrad}
"""

    # 기본 무시 잔기 목록 (yml 설정 또는 기본값)
    if ignore_residues is None:
        ignore_residues = ['HOH', 'SOL', 'NA', 'K', 'CL', 'CA', 'MG']

    # 무시할 잔기 추가
    for residue in ignore_residues:
        input_content += f"IGNORE {residue}\n"

    # 추가 카드 삽입
    if additional_cards:
        for key, value in additional_cards.items():
            input_content += f"{key} {value}\n"

    with open(input_file, 'w') as f:
        f.write(input_content)

    # 입력 PDB 파일 복사 및 DUM 원자 제거
    import shutil

    # DUM 원자 제거
    dum_removed = False
    with open(pdb_path, 'r') as f_in, open(pdb_copy, 'w') as f_out:
        for line in f_in:
            # ATOM 또는 HETATM 라인에서 DUM 원자 제거
            if line.startswith(('ATOM', 'HETATM')):
                atom_name = line[12:16].strip()
                res_name = line[17:20].strip()
                # DUM 원자 또는 DUM 잔기 스킵
                if atom_name == 'DUM' or res_name == 'DUM':
                    dum_removed = True
                    continue
            f_out.write(line)

    if dum_removed:
        print(f"  Warning: DUM 원자가 제거되었습니다.")

    # HOLE 실행
    try:
        with open(input_file, 'r') as inp, open(output_file, 'w') as out:
            result = subprocess.run(
                [HOLE_EXE],
                stdin=inp,
                stdout=out,
                stderr=subprocess.PIPE,
                cwd=work_path,
                text=True,
                timeout=120
            )

        success = result.returncode == 0

        # 최소 반지름 추출
        min_radius = None
        if success and output_file.exists():
            with open(output_file, 'r') as f:
                content = f.read()
                match = re.search(r'Minimum radius found:\s+([\d.]+)', content)
                if match:
                    min_radius = float(match.group(1))

        return {
            'success': success,
            'output_file': str(output_file),
            'sph_file': str(sph_file),
            'pdb_file': str(pdb_copy),
            'input_file': str(input_file),
            'stderr': result.stderr,
            'min_radius': min_radius
        }

    except subprocess.TimeoutExpired:
        return {'success': False, 'error': 'Timeout (>120s)'}
    except Exception as e:
        return {'success': False, 'error': str(e)}


def parse_hole_output(output_file):
    """
    HOLE 출력 파일에서 기공 반지름 프로파일 데이터 추출

    Parameters
    ----------
    output_file : str
        HOLE 출력 텍스트 파일 경로

    Returns
    -------
    list of dict
        각 위치의 기공 정보:
        - 'position': float - 채널 축을 따른 위치 (Å)
        - 'radius': float - 기공 반지름 (Å)
        - 'x', 'y', 'z': float - 3D 좌표
        - 'type': str - 'sampled' 또는 'mid-point'

    Examples
    --------
    >>> data = parse_hole_output("hole_out.txt")
    >>> positions = [d['position'] for d in data]
    >>> radii = [d['radius'] for d in data]
    """

    data = []

    with open(output_file, 'r') as f:
        content = f.read()

    # 데이터 라인 파싱 (예: "15.98775  3.69806  18.14801  4.34396  (sampled)")
    pattern = r'(-?\d+\.\d+)\s+(-?\d+\.\d+)\s+(-?\d+\.\d+)\s+(-?\d+\.\d+)\s+\((sampled|mid-point)\)'

    for match in re.finditer(pattern, content):
        position = float(match.group(1))
        x = float(match.group(2))
        y = float(match.group(3))
        z = float(match.group(4))
        point_type = match.group(5)

        # 반지름 계산 (position이 실제로는 반지름일 수 있음 - HOLE 출력 형식에 따라 조정 필요)
        data.append({
            'position': position,
            'x': x,
            'y': y,
            'z': z,
            'radius': z,  # 실제 출력 형식 확인 필요
            'type': point_type
        })

    return data


def get_minimum_radius(output_file):
    """
    HOLE 출력 파일에서 최소 기공 반지름 추출

    Parameters
    ----------
    output_file : str
        HOLE 출력 파일 경로

    Returns
    -------
    float or None
        최소 반지름 (Angstrom), 찾지 못한 경우 None
    """

    with open(output_file, 'r') as f:
        content = f.read()

    match = re.search(r'Minimum radius found:\s+([\d.]+)', content)
    if match:
        return float(match.group(1))
    return None


def get_conductance(output_file):
    """
    HOLE 출력 파일에서 예측 전도도(conductance) 추출

    Parameters
    ----------
    output_file : str
        HOLE 출력 파일 경로

    Returns
    -------
    dict or None
        전도도 정보 또는 None:
        - 'geometric_factor': float
        - 'macroscopic_conductance': float (pS)
    """

    with open(output_file, 'r') as f:
        content = f.read()

    # Geometric factor 추출
    f_match = re.search(r'F=\s*sum\(ds/area\).*?is\s+([\d.]+)', content)
    # Macroscopic conductance 추출
    g_match = re.search(r'Gmacro=\s+([\d.]+)', content)

    if f_match and g_match:
        return {
            'geometric_factor': float(f_match.group(1)),
            'macroscopic_conductance': float(g_match.group(1))
        }
    return None


def run_full_analysis(pdb_file, output_prefix="analysis", endrad=5.0,
                     work_dir="output", radius_file=None):
    """
    전체 HOLE 분석 파이프라인 실행

    1. HOLE 실행 (기공 분석)
    2. hole_plot.py 실행 (그래프 생성)
    3. hole_pymol.py 실행 (PyMOL 시각화 파일 생성)

    Parameters
    ----------
    pdb_file : str
        입력 PDB 파일 경로
    output_prefix : str
        출력 파일 접두사
    endrad : float
        채널 종료 반지름 (Angstrom)
    work_dir : str
        작업 디렉토리
    radius_file : str, optional
        반지름 파일 경로

    Returns
    -------
    dict
        전체 파이프라인 실행 결과
    """
    import sys

    print("=" * 60)
    print("HOLE 전체 분석 파이프라인")
    print("=" * 60)
    print(f"입력 파일: {pdb_file}")
    print(f"출력 위치: {work_dir}/")
    print(f"접두사: {output_prefix}")
    print(f"Endrad: {endrad}")

    # Step 1: HOLE 실행
    print("\n" + "=" * 60)
    print("Step 1: HOLE 실행")
    print("=" * 60)
    result = run_hole(
        pdb_file=pdb_file,
        output_prefix=output_prefix,
        endrad=endrad,
        work_dir=work_dir,
        radius_file=radius_file
    )

    if not result['success']:
        print(f"✗ HOLE 실행 실패: {result.get('error', 'Unknown error')}")
        return result

    print(f"✓ HOLE 실행 완료")
    print(f"  출력 파일: {result['output_file']}")
    print(f"  SPH 파일: {result['sph_file']}")
    if result['min_radius']:
        print(f"  최소 반지름: {result['min_radius']:.3f} Å")

    # Step 2: hole_plot.py 실행
    print("\n" + "=" * 60)
    print("Step 2: 그래프 생성 (hole_plot.py)")
    print("=" * 60)
    try:
        sys.path.insert(0, str(Path(__file__).parent / "scripts"))
        from hole_plot import plot_hole_profile

        # 절대 경로로 변환
        work_path = Path(work_dir).resolve()
        plot_file = work_path / f"{output_prefix}_profile.png"
        plot_hole_profile(result['output_file'], save_as=str(plot_file))
        print(f"✓ 그래프 생성 완료: {plot_file}")
        result['plot_file'] = str(plot_file)
    except ImportError as e:
        print(f"✗ matplotlib이 설치되지 않아 그래프 생성 건너뜀")
        print(f"  설치: python -m pip install matplotlib")
        result['plot_error'] = 'matplotlib not installed'
    except Exception as e:
        print(f"✗ 그래프 생성 실패: {e}")
        result['plot_error'] = str(e)

    # Step 3: hole_pymol.py 실행
    print("\n" + "=" * 60)
    print("Step 3: PyMOL 시각화 파일 생성 (hole_pymol.py)")
    print("=" * 60)
    try:
        import subprocess
        hole_pymol_script = Path(__file__).parent / "scripts" / "hole_pymol.py"
        python_exe = sys.executable

        proc = subprocess.run(
            [python_exe, str(hole_pymol_script), result['sph_file']],
            capture_output=True,
            text=True,
            timeout=120
        )

        if proc.returncode == 0:
            print(proc.stdout)
            print(f"✓ PyMOL 시각화 파일 생성 완료")

            # 생성된 파일들 결과에 추가
            base_name = Path(result['sph_file']).stem
            work_path = Path(work_dir)
            result['pore_pdb'] = str(work_path / f"{base_name}_pore_surface.pdb")
            result['pymol_script'] = str(work_path / f"{base_name}_pymol.pml")
        else:
            print(f"✗ PyMOL 시각화 파일 생성 실패")
            print(proc.stderr)
            result['pymol_error'] = proc.stderr
    except Exception as e:
        print(f"✗ PyMOL 시각화 파일 생성 실패: {e}")
        result['pymol_error'] = str(e)

    # Step 4: PyMOL PNG 자동 생성
    if 'pymol_script' in result:
        print("\n" + "=" * 60)
        print("Step 4: PyMOL PNG 렌더링")
        print("=" * 60)

        base_name = Path(result['sph_file']).stem
        work_path = Path(work_dir).resolve()
        png_output = work_path / f"{base_name}_visualization.png"

        try:
            print("PyMOL로 PNG 생성 중 (레이어별 렌더링)...")

            # PyMOL 스크립트 절대 경로
            pml_script_abs = Path(result['pymol_script']).resolve()

            # 중간 파일 경로
            surface_pore_png = work_path / f"{base_name}_temp_surface_pore.png"
            cartoon_png = work_path / f"{base_name}_temp_cartoon.png"

            import time

            # 1단계: Surface + Pore 렌더링
            print("  1/3: Surface + Pore 레이어 렌더링...")
            pymol_cmd_surface = [
                'pymol',
                '-c',
                '-d', f"@{pml_script_abs}; hide everything, protein_cartoon; set transparency, 0.6, protein_surface; orient all; zoom all, 20; ray 800, 800; png {surface_pore_png}, dpi=200; quit"
            ]

            proc1 = subprocess.run(
                pymol_cmd_surface,
                capture_output=True,
                text=True,
                timeout=180,
                cwd=str(work_path)
            )
            time.sleep(2)

            if not surface_pore_png.exists() or surface_pore_png.stat().st_size == 0:
                print(f"✗ Surface+Pore 렌더링 실패")
                raise Exception("Surface layer rendering failed")

            print(f"  ✓ Surface+Pore 렌더링 완료 ({surface_pore_png.stat().st_size/1024:.1f} KB)")

            # 2단계: Cartoon만 렌더링 (투명 배경)
            print("  2/3: Cartoon 레이어 렌더링...")
            pymol_cmd_cartoon = [
                'pymol',
                '-c',
                '-d', f"@{pml_script_abs}; hide everything, protein_surface; hide everything, pore; set ray_opaque_background, 0; set transparency, 0.4, protein_cartoon; set cartoon_transparency, 0.4, protein_cartoon; orient all; zoom all, 20; ray 800, 800; png {cartoon_png}, dpi=200; quit"
            ]

            proc2 = subprocess.run(
                pymol_cmd_cartoon,
                capture_output=True,
                text=True,
                timeout=180,
                cwd=str(work_path)
            )
            time.sleep(2)

            if not cartoon_png.exists() or cartoon_png.stat().st_size == 0:
                print(f"✗ Cartoon 렌더링 실패")
                raise Exception("Cartoon layer rendering failed")

            print(f"  ✓ Cartoon 렌더링 완료 ({cartoon_png.stat().st_size/1024:.1f} KB)")

            # 3단계: 두 이미지 합성
            print("  3/3: 이미지 합성 중...")
            try:
                from PIL import Image

                # 이미지 로드
                img_surface = Image.open(surface_pore_png).convert('RGBA')
                img_cartoon = Image.open(cartoon_png).convert('RGBA')

                # Cartoon을 Surface 위에 합성
                final_img = Image.alpha_composite(img_surface, img_cartoon)

                # 최종 이미지 저장
                final_img.save(png_output, 'PNG', dpi=(200, 200))

                # 임시 파일 삭제
                surface_pore_png.unlink()
                cartoon_png.unlink()

                if png_output.exists() and png_output.stat().st_size > 0:
                    file_size = png_output.stat().st_size
                    print(f"✓ PNG 파일 생성 완료: {png_output} ({file_size/1024:.1f} KB)")
                    result['pymol_png'] = str(png_output)
                else:
                    print(f"✗ 최종 이미지 저장 실패")

            except ImportError:
                print("✗ PIL/Pillow가 설치되지 않아 이미지 합성 실패")
                print("  설치: conda install pillow")
                # 임시 파일이라도 유지
                if surface_pore_png.exists():
                    surface_pore_png.rename(png_output)
                    print(f"  대신 Surface+Pore 이미지 저장: {png_output}")
                    result['pymol_png'] = str(png_output)

        except FileNotFoundError:
            print("✗ PyMOL 명령을 찾을 수 없습니다.")
            print("  PyMOL이 설치되어 있고 PATH에 포함되어 있는지 확인하세요.")
            print("  수동 렌더링 명령어:")
            print(f"  pymol -c -d \"@{result['pymol_script']}; orient pore; zoom pore, 5; ray 3000,3000; png {png_output}, dpi=300; quit\"")

        except subprocess.TimeoutExpired:
            print(f"✗ PyMOL 렌더링 시간 초과 (>5분)")
            print("  렌더링이 너무 오래 걸립니다. 해상도를 낮추거나 수동으로 실행하세요.")

        except Exception as e:
            print(f"✗ PNG 생성 실패: {e}")
            print("  수동 렌더링 명령어:")
            print(f"  pymol -c -d \"@{result['pymol_script']}; orient pore; zoom pore, 5; ray 3000,3000; png {png_output}, dpi=300; quit\"")
            result['pymol_png_error'] = str(e)

    # Step 5: 중간 파일 정리
    print("\n" + "=" * 60)
    print("Step 4: 중간 파일 정리")
    print("=" * 60)

    work_path = Path(work_dir).resolve()
    intermediate_dir = work_path / "intermediate_files"
    intermediate_dir.mkdir(exist_ok=True)

    # 최종 출력 파일들 (이동하지 않음)
    final_files = set()
    final_files.add(str(work_path / f"{output_prefix}.pdb"))  # 단백질 PDB
    final_files.add(str(work_path / f"{output_prefix}_pore_surface.pdb"))  # 기공 PDB
    final_files.add(str(work_path / f"{output_prefix}_profile.png"))  # 그래프
    final_files.add(str(work_path / f"{output_prefix}_pymol.pml"))  # PyMOL 스크립트
    final_files.add(str(work_path / f"{output_prefix}_visualization.png"))  # PyMOL PNG

    # 중간 파일들 (이동할 파일)
    intermediate_extensions = ['.inp', '_out.txt', '.sph', '_surface.qpt', '_surface.vmd_plot', '.tsv']
    moved_count = 0

    for ext in intermediate_extensions:
        src = work_path / f"{output_prefix}{ext}"
        if src.exists():
            dst = intermediate_dir / src.name
            src.rename(dst)
            moved_count += 1
            print(f"  이동: {src.name} → intermediate_files/")

    print(f"✓ 중간 파일 {moved_count}개를 intermediate_files/ 폴더로 정리")

    # 최종 결과 요약
    print("\n" + "=" * 60)
    print("분석 완료!")
    print("=" * 60)
    print("생성된 파일:")
    file_num = 1
    print(f"  {file_num}. 단백질 PDB: {work_path / f'{output_prefix}.pdb'}")
    file_num += 1

    if 'pore_pdb' in result:
        print(f"  {file_num}. 기공 PDB: {result['pore_pdb']}")
        file_num += 1

    if 'plot_file' in result:
        print(f"  {file_num}. 그래프: {result['plot_file']}")
        file_num += 1

    if 'pymol_script' in result:
        print(f"  {file_num}. PyMOL 스크립트: {result['pymol_script']}")
        file_num += 1

    if 'pymol_png' in result:
        print(f"  {file_num}. PyMOL 렌더링: {result['pymol_png']}")
        file_num += 1

    print(f"\n중간 파일: {intermediate_dir}/")

    print("\n시각화:")
    if 'plot_file' in result:
        print(f"  그래프: {result['plot_file']}")
    if 'pymol_png' in result:
        print(f"  PyMOL 렌더링: {result['pymol_png']}")
    if 'pymol_script' in result:
        print(f"  PyMOL 대화형: pymol {result['pymol_script']}")

    return result


if __name__ == "__main__":
    """커맨드라인 실행 인터페이스"""
    import sys
    import argparse

    parser = argparse.ArgumentParser(
        description='HOLE 전체 분석 파이프라인 (YAML 설정 파일 필수)',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
예시:
  # YAML 설정 파일 사용 (기본)
  python hole_runner.py hole_config.yml

  # 또는 --config 옵션 사용
  python hole_runner.py --config hole_config.yml
        """
    )

    parser.add_argument('config_file', nargs='?', help='YAML 설정 파일 경로')
    parser.add_argument('--config', '-c', help='YAML 설정 파일 경로 (대체 방법)')

    args = parser.parse_args()

    # 설정 파일 경로 결정
    config_file = args.config if args.config else args.config_file

    if not config_file:
        print("✗ 오류: YAML 설정 파일이 필요합니다.")
        print()
        parser.print_help()
        sys.exit(1)

    # YAML 설정 파일 로드
    import yaml

    try:
        with open(config_file, 'r') as f:
            config = yaml.safe_load(f)

        # YAML에서 파라미터 읽기
        pdb_file = config.get('pdb_file')
        output_prefix = config.get('output_prefix', 'analysis')
        endrad = config.get('endrad', 5.0)
        work_dir = config.get('work_dir', 'output')
        radius_file = config.get('radius_file')

        # radius_file이 상대 경로면 절대 경로로 변환
        if radius_file and not radius_file.startswith('/'):
            # rad 파일은 ~/MODEL/hole2/rad/ 디렉토리에 있음
            import os
            rad_dir = os.path.expanduser("~/MODEL/hole2/rad")
            radius_file = os.path.join(rad_dir, radius_file)

        if not pdb_file:
            print("✗ 오류: YAML 설정 파일에 pdb_file이 지정되지 않았습니다.")
            sys.exit(1)

        print(f"YAML 설정 파일 사용: {config_file}")

    except FileNotFoundError:
        print(f"✗ 오류: 설정 파일을 찾을 수 없습니다: {config_file}")
        sys.exit(1)
    except yaml.YAMLError as e:
        print(f"✗ 오류: YAML 파일 파싱 실패: {e}")
        sys.exit(1)

    # 전체 분석 실행
    result = run_full_analysis(
        pdb_file=pdb_file,
        output_prefix=output_prefix,
        endrad=endrad,
        work_dir=work_dir,
        radius_file=radius_file
    )

    # 종료 코드 반환
    sys.exit(0 if result['success'] else 1)
